## mysql相关

1. 什么是MySQL:

   MySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展;MySQL的默认端口号是**3306**;

2. 事务

   什么是事务：**事务是逻辑上的一组操作，要么都执行，要么都不执行**

   事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。

3. 事务的四大特性

   原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
   一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
   隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
   持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

4. 并发事务带来的问题

   并发事务：多个事务并发运行，操作相同的数据来完成各自任务，对同一数据操作；

   * 脏读：一个事务没结束，另一个事务同时访问并使用该数据，那这个事务读到的数据就是脏数据；
   * 丢失修改：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改；
   * 不可重复读：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
   * 幻读：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读

5. 乐观锁：

   总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现；用于写比较少的情况，（多读场景），即冲突真的很少发生的时候，省去了锁的开销，加大了系统的整个吞吐量；

6. 悲观锁：

   总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。写操作多的场景下，悲观锁比较好。

7. 查看数据库触发器

    show triggers like  表名

8. 如何查看sql是否使用索引

   explain +sql语句

9. 怎么查看数据库的连接数

   show processlist    当前用户的线程数   ，默认显示100条。  需显示所有条数  show  full   processlist

   需查询其他指标  可用  show  status like "%关键字 %" 

10. 查看数据库索引

    show index from 表名

11. mysql  行级锁、页级锁、表级锁

     * 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为[`共享锁`](https://zhiwangdianzi.cn/mysqlzhong-de-xing-ji-suo-biao-ji-suo-ye-ji-suo/) 和 [`排他锁`](https://zhiwangdianzi.cn/mysqlzhong-de-xing-ji-suo-biao-ji-suo-ye-ji-suo/)。特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；

     * 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为`表共享读锁`（[共享锁](http://www.hollischuang.com/archives/923)）与`表独占写锁`（[排他锁](http://www.hollischuang.com/archives/923)）；特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

     * 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁.表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

     * MyISAM和MEMORY采用表级锁(table-level locking)

       BDB采用页面锁(page-level locking)或表级锁，默认为页面锁

       InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

       前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？

       InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！

       在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。

       行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。

          **行级锁与死锁**
       MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。

         在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。

         当两个事务同时执行，一个锁住了逐渐索引在等待其他相关索引，一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。

         发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。


12. mysql 事务隔离级别

    MySQL的事务隔离级别有以下四种：

    - 读未提交。事务A可以读到事务B未提交的数据。会引起脏读。

    ​          Mysql设置事务隔离级别为读未提交：

    ​          set session transaction isolation level read uncommitted;

    - 读已提交。事务A只能读到事务B已提交的数据。不可重复读。

    ​          MySQL设置事务隔离级别为读已提交：

    ​         set session transaction isolation level read committed;

    - 可重复读。事务A无法读取事务B已提交的的数据。会产生幻读。

    ​          MySQL设置事务隔离级别为可重复读：

    ​          set session transaction isolation level repeatable read;

    - 串行化。读写操作都是串行的，如果事务A对表T进行了读或者写操作，事务B必须等事务A提交或者回滚后才能操作表T（事务A和事务B只能读同时进行）。

    ​          MySQL设置事务隔离级别为串行化：

    ​          set session transaction isolation level serializable;

13. datetime 和timestemp区别

    * 时间限制不一样，前者 1000~9999，后者 1970~2037
    * 存储字节不一样：前者8字节，后者4字节
    * 时区转化，前者与此无关，后者需要转化
    * 默认值，前者无默认值，可通过now()函数插入当前时间，后者有默认值，自动写入当前时间

14. char 和varchar区别

    * 存储速度：前者快，后者慢
    * 存储空间：前者固定长度，后者不固定（值长度+1）
    * 存储空间利用：后者更节约存储空间

    




