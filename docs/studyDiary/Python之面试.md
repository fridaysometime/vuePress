## Python之面试

   ​1. 在python中，如何交换两个变量的值？
	这个问题，考了python特殊的语法，也就是a, b = b, a，这个表达式，也是其他语言所没有的，是只有	python自带的。

2. 字符串的拼接–如何高效的拼接两个字符串？
    我们都知道python中，拼接字符串可以用”+”来拼接，然而这个方法并不是高效的，因为如果需要拼接的字符串有很多(n个)的情况下，使用”+”的话，python解释器会申请n-1次内存空间，然后进行拷贝，因为字符串在python中是不可变的，所以当进行拼接的时候，会需要申请一个新的内存空间。所以，正确答案是，使用.join(list),因为它只使用了一次内存空间。

3. list = [a,a,a,1,2,3,4,5,A,B,C]提取出”12345”
    这个考点考了python的解压赋值的知识点，即 a,b,c,*middle, e,f,g = list, *middle = [1,2,3,4,5]。注意，解压赋值提取出来的是列表。

4. python的面向对象？
    类是对象的蓝图和模板，而对象是类的实例。类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。面向对象有三大支柱：封装、继承和多态。

5. 什么是元类？
    同上，我们讲到在python中皆为对象，而元类即是用来创建类的”东西”。类也是元类的实例。而在python中，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类。元类主要的用途是用来创建API,比如django的ORM。

6. python的search和match知识点？
   search和match都在re模块中，match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None。search匹配整个字符串，直到找到一个匹配。

7. python中深浅拷贝的区别？
    浅拷贝没有拷贝子对象，所以原对象发生改变，其子对象也发生了改变，而深拷贝拷贝了子对象，原对象发生改变，其本身也不会改变。具体的可以看我之前的博客python深浅copy一分钟掌握

8. 类的初始化：new() 和 init()?
    new()方法用来实例化最终的类对象，在类创建之前被调用，它在类的主体被执行完后开始执行。 
    init()方法是在类被创建之后被调用，用来执行其他的一些输出化工作 
    当我们构造元类的时候，通常只需要定一个init()或new()方法，但不是两个都定义。但是，如果需要接受其他的关键词参数的话，这两个方法就要同时提供，并且都要提供对应的参数签名。

9. 类的初始化？
    B类继承A类，在B类自己的基础上可以调用A类所有方法，如果A,B同时拥有init， B会改写A中的init方法，A类的方法失效。 
    Super函数可以调用A类中的属性，B类中有同名属性时，覆盖A类中的同名属性。但调用函数时，总是先查找它自身的定义，如果没有定义，则顺着继承链向上查找，直到在某个父类中找到为止。 
    B类 init参数需大于或等于A 父类的init方法，因为super初始化了，参数量为父类参数量。

10. 多线程？
    多线程可以共享进程的内存空间，因此要实现多个线程之间的通信相对简单，比如设置一个全局变量，多个线程共享这个全局变量。但是当多个线程共享一个资源的时候，可能导致程序失效甚至崩溃，如果一个资源被多个线程竞争使用，那么对临界资源的访问需要加上保护，否则会处于“混乱”状态，比如银行存100块钱，最终很可能存不到一百块多个线程得到的余额状态都是0，所有操作都是在0上面加1，从而导致错误结果。这种情况下，锁就可以得到用处了。多线程并不能发挥cpu多核特性，因为python解释器有一个gil锁，任何线程执行前必须获得GIL锁，然后每执行100条字节码，解释器就会自动释放GIL锁让别的线程有机会执行。

11. python内存管理？

     python中的垃圾回收是以引用计数为主，标记-清除和分代收集为辅。

      python内部使用引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。所有这些都是自动完成，不需要像C一样，人工干预，从而提高了程序员的效率和程序的健壮性。

     引用计数：python在内存中存储每个对象的引用计数，如果计数变成0，该对象就会消失，分配给该对象的内存就会释放出来。

     标记-清除：一些容器对象，比如说list、dict、tuple、instance等可能会出现引用循环，对于这些循环，垃圾回收器会定时回收这些循环(对象之间通过引用(指针)连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边)。

     分代收集：python把内存根据对象存活时间划分为三代，对象创建之后，垃圾回收器会分配它们所属的代。每个对象都会被分配一个代，而被分配更年轻的代是被优先处理的，因此越晚创建的对象越容易被回收。

12. python的filter方法？
      filter就像map,reduce,apply,zip等都是内置函数，用C语言实现，具有速度快，功能强大等 优点。 
      用于过滤与函数func()不匹配的值, 类似于SQL中select value != ‘a’ 
      相当于一个迭代器，调用一个布尔函数func来迭代seq中的每个元素，返回一个是bool_seq返 回为True的序列 
      第一个参数: function or None, 函数或None 
      第二个参数: sequence,序列

13. 字符串的查询替换？
      考点：python的find和replace函数。 
      给定一串字符串：

```python
string = 'life is short, I use python'
# 返回的为0或正数时，为其索引号
>>> string.find('life')
>>> string.replace('short','long')
# replace 将short替换为long
>>> life is long, I use python
>>> 1
>>> 2
>>> 3
>>> 4
>>> 5
>>> 6
```
14. 给定一串排好序的列表，打乱这个函数?
这个题考了python里的shuffle函数的用法。

```python
random模块中的shuffle(洗牌函数)  
    import random  
    list = [1, 2, 3, 4]  
    random.shuffle(list)     
    print(list)
```
15. 装饰器？
    装饰器是一个函数，接收一个函数返回另一个函数。

    装饰器本质上是一个python函数，它可以让其他函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志、性能测试，事务处理、缓存、权限验证等。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。

    用法如下：
```python
import time
from functools import wraps

def timethis(func):
    '''
    Decorator that reports the execution time.
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(func.__name__, end-start)
        return result
    return wrapper
@timethis
def countdown(n):
     '''
    Counts down
     '''
     while n > 0:
         n -= 1

>>> countdown(100000)
>>> countdown 0.008917808532714844
>>> countdown(10000000)
>>> countdown 0.87188299392912”
```

16. 给定一串字典(或列表),找出指定的（前N个）最大值？最小值？
这道题的考点是python内的heapq模块的nlargest() 和 nsmallest(), 而不是min()和max()。这两个函数都能接收关键字参数，用于复杂的结构数据中：
```python
portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
#参数3为最大的3个值(最小的3个值)
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
#上面代码在对每个元素进行对比的时候，会以price的值进行比较。
```

17. ***args和\**kwargs是什么意思?**
    *args表示可变参数(variadic arguments)，它允许你传入0个或任意个无名参数，这些参数在函数调用时自动组装为一个tuple; **kwargs表示关键字参数(keyword arguments)，它允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。同时使用*args和**kwargs的时候，必须保证*args在**kwargs之前。

18. **python里面如何拷贝一个对象?**

    (1) 赋值(=)，就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个;

    (2)浅拷贝(copy.copy())，创建一个新的对象，但它包含的是对原始对象中包含项的引用(如果用引用的方式修改其中一个对象，另一个也会被改变);

    (3)深拷贝(copy.deepcopy())，创建一个新的对象，并且递归的复制它所包含的对象(修改其中一个，另一个不会改变)

    注意：并不是所有的对象都可以拷贝

19. **什么是lambda函数?它有什么好处?**

    lambda表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。

    Python允许你定义一种单行的小函数。定义lambda函数的形式如下(lambda参数：表达式)lambda函数默认返回表达式的值。你也可以将其赋值给一个变量。lambda函数可以接受任意个参数，包括可选参数，但是表达式只有一个。

20. **@classmethod和@staticmethod**

    @classmethod修饰符对应的函数不需要实例化，不需要self参数，第一个参数需要是表示自身类的cls参数，cls参数可以用来调用类的属性，类的方法，实例化对象等。

    @staticmethod返回函数的静态方法，该方法不强制要求传递参数，如下声明一个静态方法：
```python
    Class C(object):
    @staticmethod
    Def f(arg1, arg2,…):
```
​	以上实例声明了静态方法f，类可以不用实例化就可以调用该方法C.f()，也可以实例化后调用C().f()。



​    


