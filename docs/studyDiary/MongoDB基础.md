## MongoDB基础

**1. mongodb 与mysql 的区别？**
mongodb的本质还是一个数据库产品，3.0以上版本其稳定性和健壮性有很大提升。它与mysql的区别在于它不会遵循一些约束，比如：sql标准、ACID属性，表结构等。其主要特性如下：
 面向集合文档的存储：适合存储Bson（json的扩展）形式的数据；
 格式自由，数据格式不固定，生产环境下修改结构都可以不影响程序运行；
 强大的查询语句，面向对象的查询语言，基本覆盖sql语言所有能力；
 完整的索引支持，支持查询计划；
 支持复制和自动故障转移；
 支持二进制数据及大型对象（文件）的高效存储；
 使用分片集群提升系统扩展性；
 使用内存映射存储引擎，把磁盘的IO操作转换成为内存的操作；



```
特点：
高性能、易部署、易使用，存储数据非常方便。主要功能特性有：
面向集合存储，易存储对象类型的数据。
模式自由。
支持动态查询。
支持完全索引，包含内部对象。
支持查询。
支持复制和故障恢复。
使用高效的二进制数据存储，包括大型对象（如视频等）。
自动处理碎片，以支持云计算层次的扩展性
支持Python，PHP，Ruby，Java，C，C#，Javascript，Perl及C++语言的驱动程序，社区中也提供了对Erlang及.NET等平台的驱动程序。
文件存储格式为BSON（一种JSON的扩展）。
可通过网络访问。

功能：
面向集合的存储：适合存储对象及JSON形式的数据。
动态查询：Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。
完整的索引支持：包括文档内嵌对象及数组。Mongo的查询优化器会分析查询表达式，并生成一个高效的查询计划。
查询监视：Mongo包含一个监视工具用于分析数据库操作的性能。
复制及自动故障转移：Mongo数据库支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制。复制的主要目标是提供冗余及自动故障转移。
高效的传统存储方式：支持二进制数据及大型对象（如照片或图片）
自动分片以支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器。


```



**2. mongoDB 主要使用在什么应用场景？**
 MongoDB 的应用已经渗透到各个领域，比如游戏、物流、电商、内容管理、社交、物联网、视频直播等，以下是几个实际的应用案例：
 游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新
 物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。
 社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能
 物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析
 视频直播，使用 MongoDB 存储用户信息、礼物信息等

```
网站数据：Mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。
缓存：由于性能很高，Mongo也适合作为信息基础设施的缓存层。在系统重启之后，由Mongo搭建的持久化缓存层可以避免下层的数据源 过载。
大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。
高伸缩性的场景：Mongo非常适合由数十或数百台服务器组成的数据库。Mongo的路线图中已经包含对MapReduce引擎的内置支持。
用于对象及JSON数据的存储：Mongo的BSON数据格式非常适合文档化格式的存储及查询。

```



**3. 怎么样做mongodb 查询优化**
 第一步 找出慢速查询
**1. 开启内置的查询分析器,记录读写操作效率:**
        db.setProfilingLevel(n,{m}),n的取值可选0,1,2；
     0是默认值表示不记录；
     1表示记录慢速操作,如果值为1,m必须赋值单位为ms,用于定义慢速查询时间的阈值；
     2表示记录所有的读写操作；
        例如:db.setProfilingLevel(1,300)
**2. 查询监控结果**
    监控结果保存在一个特殊的盖子集合system.profile里,这个集合分配了128kb的空间,要确保监控分析数据不会消耗太多的系统性资源；盖子集合维护了自然的插入顺序,可以使用$natural操作符进行排序,如:db.system.profile.find().sort({'$natural':-1}).limit(5)

 第二步 分析慢速查询
找出慢速查询的原因比较棘手,原因可能有多个:应用程序设计不合理、不正确的数据模型、硬件配置问题,缺少索引等；接下来对于缺少索引的情况进行分析:使用explain分析慢速查询
    例如:db.orders.find({'price':{'$lt':2000}}).explain('executionStats')
    explain的入参可选值为:
     "queryPlanner" 是默认值,表示仅仅展示执行计划信息；
     "executionStats" 表示展示执行计划信息同时展示被选中的执行计划的执行情况信息；
      "allPlansExecution" 表示展示执行计划信息,并展示被选中的执行计划的执行情况信息,还展示备选的执行计划的执行情况信息；

 第三步 解读explain结果 
queryPlanner（执行计划描述）
    winningPlan（被选中的执行计划）
        stage（可选项:COLLSCAN 没有走索引；IXSCAN使用了索引）
    rejectedPlans(候选的执行计划)
executionStats(执行情况描述)
    nReturned （返回的文档个数）
    executionTimeMillis（执行时间ms）
    totalKeysExamined （检查的索引键值个数）
    totalDocsExamined （检查的文档个数）

优化目标 Tips:
\1. 根据需求建立索引
\2. 每个查询都要使用索引以提高查询效率, winningPlan. stage 必须为IXSCAN ；
\3. 追求totalDocsExamined = nReturned

4. mongodb 的索引注意事项？
5. 索引很有用,但是它也是有成本的——它占内存,让写入变慢；
6. mongoDB通常在一次查询里使用一个索引,所以多个字段的查询或者排序需要复合索引才能更加高效；
7. 复合索引的顺序非常重要
8. 在生成环境构建索引往往开销很大,时间也不可以接受,在数据量庞大之前尽量进行查询优化和构建索引；
9. 避免昂贵的查询,使用查询分析器记录那些开销很大的查询便于问题排查；
10. 通过减少扫描文档数量来优化查询,使用explai对开销大的查询进行分析并优化；
11. 索引是用来查询小范围数据的，不适合使用索引的情况：
         每次查询都需要返回大部分数据的文档，避免使用索引
         写比读多

**5. mongodb 是怎么实现高可用？**

![img](https://oscimg.oschina.net/oscnet/0def6f4df5304f96f40afe51de04bc8bc46.jpg)